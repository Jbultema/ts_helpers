import pandas as pd
import numpy as np
import datetime

from .data_preparation import *


def prepare_cal(ts_settings: dict
                    , generic_cal_path: str
                    , cal_path: str
                    , generic_date_col: str= None
                    , date_col: str= None
                  ) -> pd.core.frame.DataFrame:
    '''
    Prepare a special calendar with generic and specific events
    '''
    
    if generic_date_col is None:
        try:
            generic_date_col = ts_settings['date_col']
            generic_cal = pd.read_csv(generic_cal_path, parse_dates= [generic_date_col])
        except:
            generic_cal = pd.read_csv(generic_cal_path)

    if date_col is None:
        try:
            date_col = ts_settings['date_col']
            cal = pd.read_csv(cal_path, parse_dates= [date_col], index_col= 0)
        except:
            cal = pd.read_csv(cal_path, index_col= 0)

    # rename things specific to these calendars
    generic_cal.rename(columns= {'date': 'Date', 'event_type': 'Holiday'}, inplace= True)
    cal.columns = ['Holiday', 'Type', 'Date_start', 'Date_end']
    cal['Date_start'] = pd.to_datetime(cal['Date_start'])
    cal['Date_end'] = pd.to_datetime(cal['Date_end'])
    generic_cal['Date'] = pd.to_datetime(generic_cal['Date'])

    # expand the calendar to cover appropriate dates
    new_cal = pd.DataFrame()
    for event in cal['Holiday']:
        tmp = pd.DataFrame()
        data = cal[cal['Holiday']==event].copy()
        s= pd.to_datetime(data['Date_start']).values[0]
        e= pd.to_datetime(data['Date_end']).values[0]
        dates = pd.date_range(start= s
                              , end= e
                              , freq= 'D')
        tmp['Date'] = dates
        for col in [x for x in data.columns if 'Date' not in x]:
            tmp[col] = np.nan
            tmp[col].fillna(data[col].values[0], inplace= True)
        new_cal = new_cal.append(tmp)
        
    # combine the calendars
    cal_combo = generic_cal.append(new_cal).sort_values('Date')
    
    return cal_combo


def add_calendar_events(ts_settings: dict
                        , df: pd.core.frame.DataFrame
                        , historical_cal_path: str
                        , updated_cal_path: str= None
                       ):
    '''
    Augment scoring data with any holiday events
    '''
    
    # import historical calendar
    cal = read_file(path= historical_cal_path, file_type= get_file_type(historical_cal_path), dates= [ts_settings['date_col']])
    # update calendar if there is new information
    if updated_cal_path != None:
        try:
            updated_cal = read_file(path= updated_cal_path, file_type= get_file_type(updated_cal_path), dates= ts_settings['date_col'])
            cal = cal.append(updated_cal).drop_duplicates()
            cal.to_csv(f'training_data/historical_calendar_{datetime.datetime.now().year}_{datetime.datetime.now().month}_{datetime.datetime.now().day}', index= None)
        except:
            print('There are problems with the updated calendar file. Using the historical calendar instead')
    
    # drop select columns that are generated by calendar
    df = df.merge(cal, on= ts_settings['date_col'], how= 'left')
    
    # do some project-specific feature engineering
    # other special holiday parsing could be added here if desired
    df['Holiday_indicator'] = df['Holiday'].apply(lambda x: [1 if v is not np.nan else 0 for v in [x]][0])
    df['Black_Friday_Cyber_Monday'] = df['Holiday'].apply(lambda x: [1 if 'black friday' in str(v).lower() or 'cyber monday' in str(v).lower() else 0 for v in [x]][0])

    return df